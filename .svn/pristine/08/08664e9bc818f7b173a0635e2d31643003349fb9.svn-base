/** * ***************************************************************************** * ***************************************************************************** * clase Patron * ***************************************************************************** * ***************************************************************************** */
package siette.util.regex;import java.util.ArrayList;import java.util.Collection;import siette.util.text.Strings;/** * Patron: Automata Finito * * @author Ricardo Conejo * @version 1.2 */

public abstract class Patron {
/** Constante para indicar que se no hay concordancia con el patron */public final static int FALLO = -1;
protected String[] patron;protected boolean MODO_MAYUSCULAS; // true: No distingue mayusculas de                                    // minusculasprotected boolean MODO_ACENTOS; // true: No distingue entre acentuadas y no                                // acentuadasprotected boolean MODO_SIGNOS; // true: Ignora los signos de puntuacion                                // (Cuidado con los nmeros!)protected boolean MODO_BLANCOS; // true: Ignora los espacios en blanco y                                // tabuladoresprotected  boolean VARIACIONES; // Si se van a probar todas las posibles variaciones de la respuesta

protected Patron(String[] st, Boolean mMayusculas, Boolean mAcentos, Boolean mSignos, Boolean mBlancos, Boolean mVariaciones) {    MODO_MAYUSCULAS = mMayusculas.booleanValue();    MODO_ACENTOS = mAcentos.booleanValue();    MODO_SIGNOS = mSignos.booleanValue();    MODO_BLANCOS = mBlancos.booleanValue();    VARIACIONES = mVariaciones.booleanValue();    if (st != null && st.length > 0) {        patron = new String[st.length];        for (int i = 0; i < patron.length; i++) {            // patron[i] = normalizar(st[i]);            patron[i] = st[i];        }    } else {        patron = new String[1];        patron[0] = "";    }}

protected Patron(String st, boolean mMayusculas, boolean mAcentos, boolean mSignos, boolean mBlancos, boolean mVariaciones) {    this((String[]) null, new Boolean(mMayusculas), new Boolean(mAcentos), new Boolean(mSignos), new Boolean(mBlancos), new Boolean(mVariaciones));    patron = new String[1];    // patron[0] = normalizar(st);    patron[0] = st;}
protected Patron(String st, boolean mMayusculas, boolean mAcentos, boolean mSignos, boolean mBlancos) {	this(st, mMayusculas, mAcentos, mSignos, mBlancos, false);}protected Patron(String[] st, Boolean mMayusculas, Boolean mAcentos, Boolean mSignos, Boolean mBlancos) {	this(st, mMayusculas, mAcentos, mSignos, mBlancos, Boolean.FALSE) ;}protected Patron(String st) {    this(st, false, false, false, false, false);}
public void setVariaciones(boolean v) {    VARIACIONES = v;}//Devuelve las expresiones fuente que se han usado para construir el patronpublic String[] getPatrones() {	return patron;}//Devuelve las expresiones fuente que se han usado para construir el patronpublic String getPatron(int i) {	String resultado = null;	if (patron!=null && i<patron.length) {		resultado = patron[i];	}	return resultado;}// este metodo es el que debe redefinirse en cada clase/** * Este metodo indica si ha habido concordancia con alguno de los patrones * * @return un numero >=0 indicando el patron que encaja. * @return FALLO=-1 si no encaja con ningun patron * @param respuesta del alumno */public abstract int pertenece(String st, int kesimo);
public int vPertenece(String st, int kesimo) {	int pertenece = pertenece(st,kesimo);	if (VARIACIONES && pertenece == FALLO) {		ArrayList<String> variaciones = Strings.generarVariaciones(st);		int i=0;		while(pertenece==FALLO && i<variaciones.size()) {			String v = variaciones.get(i);		    // reset(); // conejo: STE-1363 Esto corrige un bug pequeÃ±o, y mejor no tocar este codigo....			pertenece = pertenece(v, kesimo);			i++;		}	}	return pertenece;}protected void reset() {	// STE-1363 Necesario por el momento solo en el patron de Expresion regular}/** * evalua un conjunto de respuestas y devuelve la concordancia con los patrones. * la respuesta se considera correcta si es distinta a las anteriores y * pertenece al patron i * * @param respuestas del alumno */public int[] pertenece(String st[]) {    int correcta[] = new int[st.length];    for (int i = 0; i < st.length; i++) {        correcta[i] = pertenece(normalizar(st[i]), nIguales(st,i));    }    return correcta;}

public int pertenece(String st) {	return pertenece(st,0);}public String refuerzo(String plantilla, String respuesta, int idioma) {	return plantilla;}public String refuerzo(String plantilla, String[] respuesta, int idioma) {	String refuerzo = "";	if (respuesta!=null) {	    for (int i = 0; i < respuesta.length; i++) {	    	if (!refuerzo.contains(plantilla)) {	    		// evitar refuerzos repetidos		        refuerzo += refuerzo(plantilla, respuesta[i], idioma);	    	}	    }	} else {		refuerzo = plantilla;	}    return refuerzo;}public String toString() {    String st = "";    for (int i = 0; i < patron.length; i++) {        st += patron[i] + "|\n";    }    return st;}
protected String normalizar(String st) {    if (st == null)        return ""; // ASSERT    st = st.trim();	st = Strings.cambiarHTML(st);    if (MODO_BLANCOS) {        st = eliminarBlancos(st);        // System.out.println("eliminarBlancos(st)=<"+st+">");    }    if (MODO_ACENTOS) {        st = eliminarAcentos(st);        // System.out.println("eliminarAcentos(st)=<"+st+">");    }    if (MODO_MAYUSCULAS) {        st = st.toUpperCase();        // System.out.println("toUpperCase(st)=<"+st+">");    }    if (MODO_SIGNOS) {        st = eliminarSignos(st);        // System.out.println("eliminarSignos(st)=<"+st+">");    }    return st;}

// si la k-esima entrada (la respuesta) es distinta a las anteriorespublic boolean distinta(String st[], int k) {    if (k > st.length)        return false;    for (int i = 0; i < k; i++) {        if (normalizar(st[i]).equals(normalizar(st[k]))) {            return false;        }    }    return true;}
//Cuantas respuestas hay iguales anteriores a la k-esima entrada (la respuesta) // 0 => que es distinta a las anteriorespublic int nIguales(String st[], int k) { int conta = 0; if (k <= st.length) {	 for (int i = 0; i < k; i++) {	     if (normalizar(st[i]).equals(normalizar(st[k]))) {	         conta++;	     }	 } } return conta;}
public String eliminarAcentos(String in) {
    return Strings.eliminarAcentos(in);}
public String eliminarSignos(String in) {    return Strings.eliminarSignosPuntuacion(in);}public String eliminarBlancos(String in) {    return Strings.eliminarBlancos(in);}
}
